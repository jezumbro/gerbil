from datetime import datetime
from pathlib import Path
from typing import List, Tuple

from loguru import logger

from model import PrintParams
from move_commands import (
    close_valve,
    header,
    move_statement,
    move_z_direction,
    open_valve,
)


def process_g1_coords(line: str):
    p = False
    coord = [0, 0, 0]
    for l in line.split(" ")[1:]:
        if "X" in l.upper():
            coord[0] = float(l.replace("X", ""))
        if "Y" in l.upper():
            coord[1] = float(l.replace("Y", ""))
        if "Z" in l.upper():
            coord[2] = float(l.replace("Z", ""))
        if "E" in l.upper():
            p = True
    return coord, p


def calculate_delta(previous, new):
    return {
        "x": new[0] - previous[0],
        "y": new[1] - previous[1],
        "z": new[2] - previous[2],
    }


def process_g1(
    line: str, params: PrintParams, printing: bool, previous: Tuple[float, float, float]
):
    new, status = process_g1_coords(line)
    if new[-1] != 0 or new == [0, 0, 0]:
        return [], previous, printing
    move = move_statement(**calculate_delta(previous, new))
    if printing != status:
        if printing:
            return (
                [
                    *close_valve(params.close_speed, params.close_delay),
                    *move_z_direction(params.exit_speed, params.travel_height),
                    f"speed {params.travel_speed}",
                    move,
                ],
                new,
                False,
            )
        return (
            [
                *move_z_direction(params.approach_speed, -params.travel_height),
                f"speed {params.print_speed}",
                *open_valve(
                    params.valve_distance, params.open_speed, params.open_delay
                ),
                move,
            ],
            new,
            True,
        )
    return [move], new, printing


def process_gcode(params: PrintParams, lines: List[str]):
    previous = (0, 0, 0)
    printing = False
    out_lines = [
        f"// optimization script generated by gerbil",
        f"// {datetime.now()}",
        f"speed {params.travel_speed:.3f}",
        *move_z_direction(params.exit_speed, params.travel_height),
    ]
    for line in lines:
        key = line.split(" ")[0].upper()
        if key != "G1":
            continue
        o, new, printing = process_g1(line, params, printing, previous)
        previous = new
        out_lines.extend(o)
    if printing:
        out_lines.extend(
            [
                *close_valve(params.close_speed, params.close_delay),
                move_z_direction(params.exit_speed, params.travel_height),
            ]
        )
    return out_lines


def get_output_file(file: Path):
    o = str(file.absolute())
    return o.split(".")[0] + ".txt"


def get_input_file(file: Path):
    o = str(file.absolute())
    return o.split(".")[0] + ".gcode"


def write_psj_file(params: PrintParams, file: Path):
    output = get_output_file(file)
    file = get_input_file(file)
    with open(file, "r") as fp:
        data = fp.readlines()
    lines = process_gcode(params=params, lines=data)
    with open(output, "w") as fp:
        fp.write("\n".join(lines))
    logger.info(f"created psj file: {output}")


if __name__ == "__main__":
    from pprint import pprint

    from settings import config

    q = config.design_file.replace(".gbr", ".gcode")
    file = Path(q)
    write_psj_file(PrintParams(), file)
