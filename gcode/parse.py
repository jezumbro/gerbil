from datetime import datetime
from pathlib import Path
from typing import List, Tuple

from loguru import logger

from model import PrintParams
from move_commands import close_valve, move_statement, move_z_direction, open_valve
from util import first


def process_g1_coords(line: str):
    p = False
    coord = [0, 0]
    line = line.split(";")[0]
    for l in line.split(" ")[1:]:
        if "X" in l.upper():
            coord[0] = float(l.replace("X", ""))
        if "Y" in l.upper():
            coord[1] = float(l.replace("Y", ""))
        if "E" in l.upper():
            p = True
    return tuple(coord), p


def calculate_delta(previous, new):
    return {
        "x": new[0] - previous[0],
        "y": new[1] - previous[1],
    }


def process_g1(
    line: str, params: PrintParams, printing: bool, previous: Tuple[float, float]
):
    new, status = process_g1_coords(line)
    if new == (0, 0):
        return [], previous, printing
    move = move_statement(**calculate_delta(previous, new))
    if printing != status:
        if printing:
            return close_valve_move(move, new, params)
        return open_valve_move(move, new, params)
    return [move], new, printing


def close_valve_move(move, new, params):
    return (
        [
            *close_valve(params.close_speed, params.close_delay),
            *move_z_direction(params.exit_speed, params.travel_height),
            f"speed {params.travel_speed}",
            move,
        ],
        new,
        False,
    )


def open_valve_move(move, new, params):
    return (
        [
            *move_z_direction(params.approach_speed, -params.travel_height),
            f"speed {params.print_speed}",
            *open_valve(params.valve_distance, params.open_speed, params.open_delay),
            move,
        ],
        new,
        True,
    )


def process_gcode(params: PrintParams, lines: List[str]):
    previous = (0, 0)
    printing = False
    out_lines = [
        f"// optimization script generated by gerbil",
        f"// {datetime.now()}",
        f"speed {params.travel_speed:.3f}",
        *move_z_direction(params.exit_speed, params.travel_height),
    ]
    for line in lines:
        key = line.split(" ")[0].upper()
        if key != "G1":
            continue
        o, new, printing = process_g1(line, params, printing, previous)
        previous = new
        out_lines.extend(o)
    if printing:
        out_lines.extend(
            [
                *close_valve(params.close_speed, params.close_delay),
                move_z_direction(params.exit_speed, params.travel_height),
            ]
        )
    return out_lines


def get_output_file(file: Path):
    o = str(file.absolute())
    return Path(o.split(".")[0] + ".txt")


def get_input_file(file: Path):
    o = str(file.absolute())
    return Path(o.split(".")[0] + ".gcode")


def write_psj_file(params: PrintParams, file: Path):
    output = get_output_file(file)
    file = get_input_file(file)
    with open(file, "r") as fp:
        data = fp.readlines()
    lines = process_gcode(params=params, lines=data)
    with open(output, "w") as fp:
        fp.write("\n".join(lines))
    logger.info(f"created psj file: {output}")


if __name__ == "__main__":
    from pprint import pprint

    from settings import config

    q = config.design_file.replace(".gbr", ".gcode")
    file = Path(q)
    write_psj_file(PrintParams(), file)
